{"name":"ineed","tagline":"Web scraping and HTML-reprocessing. The easy way.","body":"![logo](https://raw.github.com/inikulin/ineed/master/logo.png)\r\n\r\n*Web scraping and HTML-reprocessing. The easy way.*\r\n\r\n`ineed` allows you collect useful data from web pages using simple and nice API. Let's collect images, hyperlinks, scripts and stylesheets from www.google.com:\r\n\r\n```js\r\n\r\nvar ineed = require('ineed');\r\n\r\nineed.collect.images.hyperlinks.scripts.stylesheets.from('http://www.google.com',\r\n    function (err, response, result) {\r\n        console.log(result);\r\n    });\r\n\r\n```\r\n\r\nAlso, it can be used to build HTML-reprocessing pipelines (like [jch/html-pipeline](https://github.com/jch/html-pipeline) but for Node) with elegance. E.g. we have the following `html`:\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title></title>\r\n    <style type=\"text/css\">\r\n        border-radius()\r\n          -webkit-border-radius: arguments\r\n          -moz-border-radius: arguments\r\n          border-radius: arguments\r\n\r\n        ul\r\n          margin: 5px\r\n          border: 1px solid\r\n          border-radius: 5px\r\n    </style>\r\n</head>\r\n<body>\r\nThis is an H1\r\n=============\r\n*   Red\r\n*   Green\r\n*   Blue\r\n</body>\r\n</html>\r\n```\r\n\r\nLet's render it's `<style>` with [stylus](https://github.com/learnboost/stylus) and convert text from Markdown to HTML using [marked](https://github.com/chjj/marked) then assemble results back to HTML: \r\n\r\n```js\r\nvar ineed = require('ineed'),\r\n    stylus = require('stylus'),\r\n    marked = require('marked');\r\n\r\nfunction renderStylus(code) {\r\n    var css = null;\r\n\r\n    stylus.render(code, null, function (err, result) {\r\n        css = result;\r\n    });\r\n\r\n    return css;\r\n}\r\n\r\nvar resultHtml = ineed.reprocess.cssCode(renderStylus).texts(marked).fromHtml(html);\r\n```\r\n\r\nAnd the `resultHtml` will be:\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title></title>\r\n    <style type=\"text/css\">\r\n        .ul {\r\n            margin: 5px;\r\n            border: 1px solid;\r\n            -webkit-border-radius: 5px;\r\n            -moz-border-radius: 5px;\r\n            border-radius: 5px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<h1 id=\"this-is-an-h1\">This is an H1</h1>\r\n<ul>\r\n    <li>Red</li>\r\n    <li>Green</li>\r\n    <li>Blue</li>\r\n</ul>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n`ineed` doesn't build and traverse DOM-tree, it operates on sequence of HTML tokens instead. Whole processing is done in  [one-pass](http://en.wikipedia.org/wiki/One-pass_algorithm), therefore, **it's blazing fast**! The token stream is produced by [parse5](https://github.com/inikulin/parse5) which parses HTML exactly the same way modern browsers do.\r\n\r\n\r\n`ineed` provides built-in collectors and reprocessors that covers a wide variety of common use cases. However, if you feel that something is missing, then you can easily extend `ineed` with [custom plugins](#custom-plugins).\r\n\r\n##Install\r\n```\r\n$ npm install ineed\r\n```\r\n\r\n##Usage\r\nThe general form:\r\n\r\n####```ineed.<action>[.<plugin>...].<from*>```\r\n\r\n\r\n###from* methods\r\n#####.fromHtml(html)\r\nAccepts `html` string as an argument and synchronously returns `result` of the action.\r\n\r\n*Example:*\r\n```js\r\nvar result = ineed.collect.texts.fromHtml('<div>Hey ya</div>');\r\n```\r\n\r\n#####.from(options, callback)\r\nAsynchronously loads specified page and invokes `callback(err, response, result)`. It passes `response` object to `callback` in case if you need response headers or status codes. The first argument can be either a `url` or an `options` object.\r\nThe set of options is the same as in @mikeal's [request](https://github.com/mikeal/request#requestoptions-callback), so you can use POST method, set request headers or do any other advanced setup for the page request.\r\n\r\n*Examples:*\r\n```js\r\nineed.collect.jsCode.from('https://github.com', function (err, response, result) {\r\n    console.log(response.statusCode);\r\n    console.log(response.headers);    \r\n});\r\n```\r\n```js\r\nineed.collect.title.from({\r\n    url: 'https://test.domain/',\r\n    method: 'POST',\r\n    form: 'input=test'\r\n}, function (err, response, result) {\r\n    console.log(result);\r\n});\r\n\r\n```\r\n\r\n\r\n###.collect action\r\nCollects information specified by plugin set. The `result` of the action is an object that contains individual plugin outputs as properties.\r\n\r\n*Example*:\r\n```js\r\nvar result = ineed.collect.texts.images.scripts.fromHtml(html);\r\n```\r\nwill produce `result`:\r\n```js\r\n{\r\n    \"texts\" : <collected texts>,\r\n    \"images\" : <collected images>,\r\n    \"scripts\" : <collected scripts>\r\n}\r\n```\r\nBuilt-in plugins:\r\n\r\n| Plugin|Description| Output |\r\n--- | --- | ---\r\n`.comments`| Collects HTML comments| Array of comment string\r\n`.cssCode`| Collects CSS code enclosed in `<style>` tags| Array of CSS code strings\r\n`.hyperlinks`| Collects URL (*see remark below*) and text of the hyperlinks | Array of `{href:[String], text:[String]}` objects \r\n`.images`| Collects absolute URL (*see remark below*) and `alt` attribute of the images | Array of `{src:[String], alt:[String]}` objects \r\n`.jsCode`| Collects JavaScript code enclosed in `<script>` tags |Array of JavaScript code strings\r\n`.scripts` |Collects URL (*see remark below*) of the external `.js`-files, specified via `<script>` tags with `src` attribute  | Array of script URLs\r\n`.stylesheets`| Collects URL (*see remark below*) of the external `*.css`-files, specified via `<link>` tag| Array of stylesheet URLs\r\n`.texts`| Collects all text nodes in `<body>` of the document with except for `<script>` and `<style>` tag's content. Speaking clearly: all end-user visible text.  | Array of text strings\r\n`.title`| Collects document title | Document title string\r\n\r\n*Remark:* All URLs are collected in respect to `<base>` tag. The resulting URL will be an absolute URL if `.from()` method was used, `<base>` tag constains absolute URL or raw collected URL is already absolute.\r\n\r\n\r\n###.reprocess action\r\nApplies plugins' replacing functions to the source HTML-string. The `result` of the action is the reprocessed HTML-string.\r\n\r\n*Example*:\r\n```js\r\n//Delete all HTML comments and render emoji\r\nvar result = ineed.reprocess\r\n    .comments(function() {\r\n        return null;\r\n    })\r\n    .texts(function(text, escapeHtml) {\r\n        return escapeHtml(text).replace(/:beer:/g, '<img src=\"emoji/unicode/1f37a.png\" alt=\":beer:\">');\r\n    })\r\n    .fromHtml(html);\r\n```\r\n\r\nBuilt-in plugins:\r\n\r\n| Plugin        | `replacer` arguments | Description |\r\n--- | --- | ---\r\n`.comments(replacer)`|`replacer(commentString)` | Replaces HTML `commentString` with the value returned by `replacer`. Comment will be deleted from markup if `null` is returned.\r\n`.cssCode(replacer)`|`replacer(cssCodeString)` | Replaces `cssCodeString` enclosed in `<style>` tag with the value returned by `replacer`.\r\n`.hyperlinks(replacer`)|`replacer(pageBaseUrl, hrefAttrValue)`| Replaces `<a>` tag `href` attribute value with the value returned by `replacer`. \r\n`.images(replacer)`|`replacer(pageBaseUrl, srcAttrValue)` | Replaces `<img>` tag `src` attribute value with the value returned by `replacer`. \r\n`.jsCode(replacer)`|`replacer(jsCodeString)` | Replaces `jsCodeString` enclosed in the `<script>` tag with the value returned by `replacer`.\r\n`.scripts(replacer)` | `replacer(pageBaseUrl, srcAttrValue)`| Replaces `<script>` tag `src` attribute value with the value returned by `replacer`. \r\n`.stylesheets(replacer)`|`replacer(pageBaseUrl, hrefAttrValue)`| Replaces `<link rel=\"stylesheet\">` tag `href` attribute value with the value returned by `replacer`. \r\n`.texts(replacer)`| `replacer(text, escapeHtmlFunc)`| Replaces `text` with the value returned by `replacer`. Returned value will be not HTML escaped, so HTML code can be used as `replacer` result. You can manually apply `escapeHtmlFunc(str)` to force HTML escaping of the result.\r\n`.title(replacer)`|`replacer(title)` | Replaces page `title` with the value returned by `replacer`.\r\n\r\n##Custom plugins\r\nThere are two kinds of plugins: those that extends `.collect` action and those that extends `.reprocess` action. To enable plugin use `.using()` function, which will return new instance of `ineed` with enabled plugin.\r\n\r\n*Example:*\r\n```js\r\nineed\r\n    .using(myPlugin1)\r\n    .using(myPlugin2)\r\n    .collect\r\n    ...\r\n```\r\n\r\n###Common structure\r\n\r\nPlugins of both kinds are objects and in addition to the kind-specific properties they should have the following properties:\r\n####.extends\r\nIndicates which action will be extended by plugin. Can be `'collect'` or `'reprocess'`. Required property.\r\n\r\n#### .name\r\nName of the plugin. Required property. It should reflect the target of the plugin action. Plugin will be accessable under the `name` in the `.collect` or `.reprocess` objects and will be used as result property name for `.collect` action. E.g. `plugin` has `name='tagNames'`. If it extends `.collect`:\r\n```js\r\n//Enable plugin and use it\r\nvar result = ineed.using(plugin).collect.tagNames.fromHtml(html);\r\n\r\n//Access plugin results\r\nvar pluginResults = result.tagNames;\r\n```\r\n\r\nIf it extends `.reprocess`:\r\n```js\r\n var reprocessedHtml = ineed\r\n        .using(plugin)\r\n        .reprocess\r\n        .tagNames(function (tagName) {\r\n            if (tagName === 'applet')\r\n                return 'object';\r\n        })\r\n        .fromHtml(html);\r\n```\r\n\r\n#### .init(ctx, ...)\r\nFunction that initializes plugin. Required field. It always receives `ctx` object as it first argument. `ctx` contains\r\nsome useful common information regarding current pipeline state:\r\n#####ctx.baseUrl \r\nBase URL of all resources on the page with respect to `<base>` tag.\r\n\r\n#####ctx.leadingStartTag\r\nLeading non-self-closing start tag for the current HTML token. Can be used to determine parent of the text nodes. Will be `null` if the leading start tag was self-closing or any leading end tag was met.\r\n\r\n#####ctx.inBody\r\nIndicates if emitted tokens are in `<body>` tag. \r\n\r\n####Token handlers\r\nPlugin can have one or more HTML token handlers:\r\n*  `.onDoctype(doctype)`\r\n \r\nWhere `doctype`:\r\n```js\r\n{\r\n    name: [String],\r\n    publicId: [String],\r\n    systemId: [String]\r\n}\r\n```\r\n\r\n*  `.onStartTag(startTag)`\r\n \r\nWhere `startTag`: \r\n```js\r\n{\r\n    tagName: [String],\r\n    attrs: [Array],\r\n    selfClosing: [Boolean]\r\n}\r\n```\r\n*  `.onEndTag(tagName)`\r\n*  `.onText(text)`\r\n*  `.onComment(commentText)`\r\n\r\n\r\n###Collecting plugins\r\nCollecting plugins in addition to [common properties](#common-structure) should have `.getCollection()` method that should return items collected by plugin.\r\n\r\n*Example of the collecting plugin:*\r\n```js\r\n//Collects tagNames in <body>\r\nvar plugin = {\r\n    extends: 'collect',\r\n    name: 'tagNamesInBody',\r\n\r\n    init: function (ctx) {\r\n        this.ctx = ctx;\r\n        this.tagNames = [];\r\n    },\r\n\r\n    addTagName: function (tagName) {\r\n        if (this.ctx.inBody && this.tagNames.indexOf(tagName) < 0)\r\n            this.tagNames.push(tagName);\r\n    },\r\n\r\n    onStartTag: function (startTag) {\r\n        this.addTagName(startTag.tagName);\r\n    },\r\n\r\n    onEndTag: function (tagName) {\r\n        this.addTagName(tagName);\r\n    },\r\n\r\n    getCollection: function () {\r\n        return this.tagNames;\r\n    }\r\n};\r\n\r\n//Let's use it\r\nvar results = ineed.using(plugin).collect.tagNamesInBody.fromHtml(html);\r\nconsole.log(results.tagNamesInBody);\r\n```\r\n\r\n###Reprocessing plugins\r\nReprocessing plugin's `init` method in addition to `ctx` object receives all arguments passed to plugin in pipeline (e.g. `replacer()` function). If token handler returns `null` then token will be deleted from the pipeline and no farther processing by other plugins will be performed on it and it will not appear in the resulting HTML. If handler returns modified token then it will be passed to the farther plugins and will appear in the resulting HTML. If handler doesn't returns value or returns `undefined` then token will be passed unmodified to the farther plugins.\r\n\r\n*Example of the reprocessing plugin:*\r\n```js\r\n//Replaces or deletes tagNames in <body>\r\nvar plugin = {\r\n    extends: 'reprocess',\r\n    name: 'tagNamesInBody',\r\n\r\n    init: function (ctx, replacer) {\r\n        this.ctx = ctx;\r\n        this.replacer = replacer;\r\n    },\r\n\r\n    onStartTag: function (startTag) {\r\n        if (this.ctx.inBody) {\r\n            startTag.tagName = this.replacer(startTag.tagName);\r\n\r\n            //Delete token if tagName is null\r\n            return startTag.tagName === null ? null : startTag;\r\n        }\r\n    },\r\n\r\n    onEndTag: function (tagName) {\r\n        if (this.ctx.inBody)\r\n            return this.replacer(tagName);\r\n    }\r\n};\r\n\r\n//Let's use it\r\nvar reprocessedHtml = ineed\r\n    .using(plugin)\r\n    .reprocess\r\n    .tagNamesInBody(function (tagName) {\r\n        //Delete <noscript> start and end tags\r\n        if (tagName === 'noscript')\r\n            return null;\r\n        \r\n        //Replace <div> with <p>\r\n        if(tagName === 'div')\r\n            return 'p';\r\n            \r\n        return tagName;\r\n    }).fromHtml(html);\r\n\r\n```\r\n\r\n##Testing\r\n```\r\n$ npm test\r\n```\r\n\r\n##Questions or suggestions?\r\nIf you have any questions, please feel free to create an issue [here on github](https://github.com/inikulin/ineed/issues).\r\n\r\n\r\n##Author\r\n[Ivan Nikulin](https://github.com/inikulin) (ifaaan@gmail.com)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}